# محتوى اليوم الاول - الاسبوع الثاني  
Introduction to Spring-Beans-Conroller

- منظم مكتبات Package Manager وظيفته تنظيم و تثبيت المكتبات الخارجية.
- مصطلح RestApi أسلوب أساسي لنقل البيانات على الشبكة يمكن التعرف عليه أكثر من [هنا](https://www.redhat.com/en/topics/api/what-is-a-rest-api#:~:text=A%20REST%20API%20(also%20known,by%20computer%20scientist%20Roy%20Fielding.).
- مصطلح CRUD
    - إضافة Create.
    - قراءة Read.
    - تحديث Update.
    - حذف Delete.
- ملف Json Object هو طريقة لعرض البيانات وإرسال البيانات وتكون بهذا الشكل:
    {"name":"John", "age":30, "car":null}
- ملف XML هو طريقة لترتيب وعرض البيانات.
    <note>
        <to>Tove</to>
        <from>Jani</from>
        <heading>Reminder</heading>
        <body>Don't forget me this weekend!</body>
    </note>
# مقدمة Spring Boot 
- مقدمة عن إطار العمل Spring Boot.
- الفرق بين Spring Framework و Spring Boot.
- متطلبات التشغيل.
- تثبيت المتطلبات.
    - نظام Windows.
    - نظام Mac.
- بناء مشروع Hello World.
## مقدمة عن إطار العمل Spring

يساعدك Spring Boot على إنشاء تطبيقات قائمة بذاتها جاهزة للتشغيل وبشكل سريع، بحيث يمكنك البدء بأقل قدر من التعقيد. تحتاج معظم تطبيقات Spring Boot إلى القليل جدًا من التخصيص لتكون جاهزة للعمل.


![What is Spring Boot](https://static.javatpoint.com/springboot/images/what-is-spring-boot.png)


مميزات Spring Boot الأساسية هي:

- توفير تجربة بدء أسرع بشكل جذري عن طريق استخدام Spring.io.
- يدعم أكثر من لغة مثل Kotlin و Java.
- توفير تجربة تطوير أسرع عن طريق الاستغناء عن بعض المتطلبات مثل استخدام ملفات XML.
## متطلبات التشغيل
- يتطلب استخدام Spring Boot تثبيت Java ويدعم حاليًا إصدارات Java 8 و Java 11 و Java 17.
- استخدام محرر نصوص، وفي هذه المقالة سنستخدم [VScode](https://code.visualstudio.com/docs/languages/java) ويمكنك استخدام محرارات أخرى مثل IntelliJ IDEA.
- تثبيت منظم مكتبات (Package Manager) للغة Java مثل Maven أو Gradle.


## تثبيت متطلبات التشغيل
- نقوم بتثبيت Java عن طريق تثبيت Java Devlopment Kit من الموقع [هنا](https://www.azul.com/downloads/?version=java-17-lts&os=macos&package=jdk).
## نظام Mac
- نقوم بتثبيت Homebrew من [هنا](https://brew.sh/) عن طريق نسخ السطر التالي في Terminal:
    /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
- تثبيت Maven عن طريق كتابة السطر التالي في Terminal بعد تثبيت brew:
    brew install maven
- خيار آخر هو تثبيت Gradle عن طريق كتابة السطر التالي في Terminal بعد تثبيت Homebrew:
    brew install gradle


## بناء مشروع Spirng Boot عن طريق Spring Boot Initializr

من أجل القيام بأول مشروع Spring Boot سوف نتجه إلى موقع [Spring Boot Initializr](https://start.spring.io) والذي سيمكننا من إنشاء مشروع Spring Boot بشكل بسيط وسريع.
 

![Spring Boot Initializr](https://paper-attachments.dropbox.com/s_4E5081556D8D7995404A88F735C9A07394B3AAF32E4850A4FE39753C3240EBAD_1637503118742_Untitled.png)


**البيانات المهمة:**

1. نوع المشروع
    1. مشروع Meven: سوف ينشئ مشروع يحتوي على Meven كمنظم لملفات المشروع **(اختيارنا)****.**
    2. مشروع Gradle: سوف ينشئ مشروع يحتوي على Gradle كمنظم لملفات المشروع.
2. إصدار Spring Boot من الأفضل **اخت****ي****ار** **أ****خر نسخة مستقرة****.**
3. نوع الضغط
    1. نوع الضغط Jar.
    2. نوع الضغط Jar.
4. إصدار لغة Java.
5. المكتبات الداعمة
    1. قمنا بإضافة مكتبة Spring Web والتي من خلالها يمكننا بناء تطبيقات Web.


## ملفات المشروع

بعد تحميل الملف من موقع Spring Boot Initializr سوف نحصل على مشروع يحتوي على هذا الترتيب: 

![](https://paper-attachments.dropbox.com/s_4E5081556D8D7995404A88F735C9A07394B3AAF32E4850A4FE39753C3240EBAD_1637580930718_image.png)

- ملف `pom.xml` هو الملف الخاص بإضافة المكتبات المساندة ويمكننا من خلاله إضافة مكتبات جديدة إلى مشروعنا.
- مجلد `main` وهو المجلد المسؤول عن إضافة ملفات البرمجة الخاصة بالمشروع.
- مجلد `respurce` هو المشروع الخاص بإضافة الملفات المتعلقة بالموارد مثل الصور أو ملفات HTML.


## تشغيل المشروع 

لتشغيل المشروع علينا أولًا التوجه إلى موقع المشروع ثم القيام بكتابة هذا الأمر في Terminal:

    mvn spring-boot:run 

عند كتابة هذا الأمر سيقوم مدير الملفات `Meven` بتحميل الملفات الخاصة بالمكتبات الخارجية ثم تشغيل المشروع:

![](https://paper-attachments.dropbox.com/s_4E5081556D8D7995404A88F735C9A07394B3AAF32E4850A4FE39753C3240EBAD_1637581330112_image.png)


وبعدها سوف يقوم بتشغيل مشروع Spring Boot.


## إضافة Hello World Api

في البداية سوف نتجه إلى ملف `ProjectApplication.java`، ثم سنقوم بتعديل الملف التالي:

    package com.grooup.project;
    import org.springframework.boot.SpringApplication;
    import org.springframework.boot.autoconfigure.SpringBootApplication;
    import org.springframework.web.bind.annotation.RestController;
    import org.springframework.web.bind.annotation.GetMapping;
    @SpringBootApplication
    @RestController
    public class ProjectApplication {
        public static void main(String[] args) {
            SpringApplication.run(ProjectApplication.class, args);
        }
        @GetMapping("/helloWorld")
        public String helloWorld() {
            return "Hello World";
        }
    } 
- قمنا بإضافة `Annotaion` باسم `Rest Controller` وهو المسؤول عن تحديد ما إذا كان هذا `C``lass` لديه خواص `C``ontroller` مثل استقبال الطلبات `R``equest`، وسنتعرف عليه بشكل أكبر لاحقًا.
- قمنا بإضافة `Annotaion` باسم `GetMapping` ثم قمنا بإضافة `F``unction` اسمها `helloWorld`. وظيفة `GetMapping` أنها تبين أن `F``unction` عبارة عن getRequest ويمكننا الوصول إليها عن طريق هذا المسار `"helloWorld/"`.

والآن سنقوم بتشغيل المشروع مرة أخرى ونتجه إلى الرابط التالي في المتصفح، وهو رابط `localhost`؛ وذلك لأن المشروع يعمل على مستضيف من نفس الجهاز:

    http://localhost:8080/helloWorld


![](https://paper-attachments.dropbox.com/s_4E5081556D8D7995404A88F735C9A07394B3AAF32E4850A4FE39753C3240EBAD_1637582895855_image.png)


نلاحظ عبارة “Hello World” وهي نفس العبارة التي قمنا بكتابتها داخل `F``unction` التي عرفناها مسبقًا باسم `helloWorld()`.



----------


# Spring framework 


- **Spring Data:**

It simplifies data access from the relational and **NoSQL** databases.

- **Spring Batch:** 

It provides powerful **batch** processing.

- **Spring Security:** 

It is a security framework that provides robust **security** to applications.

- **Spring Social:** 

It supports integration with **social networking** like LinkedIn.

- **Spring Integration**

It is an implementation of Enterprise Integration Patterns. It facilitates integration with other **enterprise applications** using lightweight messaging and declarative adapters.



----------


## Advantages of Spring Boot
- It creates **stand-alone** Spring applications that can be started using Java **-jar**.
- It tests web applications easily with the help of different **Embedded** HTTP servers such as **Tomcat, Jetty,** etc. We don't need to deploy WAR files.
- It provides opinionated '**starter**' POMs to simplify our Maven configuration.
- It provides **production-ready** features such as **metrics, health checks,** and **externalized configuration**.
- There is no requirement for **XML** configuration.
- It offers a **CLI** tool for developing and testing the Spring Boot application.
- It offers the number of **plug-ins**.
- It also minimizes writing multiple **boilerplate codes** (the code that has to be included in many places with little or no alteration), XML configuration, and annotations.
- It **increases productivity** and reduces development time.



----------


# Controller Layer in Spring Boot

**The controller (presentation layer, or port)** is a protocol interface which exposes application functionality as RESTful web services. It should to that and nothing more.


----------


# Spring Boot Annotations

Spring Boot Annotations is a form of metadata that provides data about a program. In other words, annotations are used to provide **supplemental** information about a program. It is not a part of the application that we develop. It does not have a direct effect on the operation of the code they annotate. It does not change the action of the compiled program.
In this section, we are going to discuss some important **Spring Boot Annotation** that we will use later in this tutorial.

## Core Spring Framework Annotations

**@Required:** It applies to the **bean** setter method. It indicates that the annotated bean must be populated at configuration time with the required property, 

**Example**

    public class Machine   
    {  
    private Integer cost;  
    @Required  
    public void setCost(Integer cost)   
      {  
    this.cost = cost;  
     }  
    public Integer getCost()   
     {  
    return cost;  
    }     
     }  

**@Autowired:** Spring provides annotation-based auto-wiring by providing @Autowired annotation. It is used to autowire spring bean on setter methods, instance variable, and constructor. When we use @Autowired annotation, the spring container auto-wires the bean by matching data-type.

**Example**

    @Component  
    public class Customer  
     {  
     private Person person;  
     @Autowired  
     public Customer(Person person)   
       {   
       this.person=person;  
      }  
      }  

**@Configuration:** It is a class-level annotation. The class annotated with @Configuration used by Spring Containers as a source of bean definitions.

**Example**

    @Configuration  
    public class Vehicle  
    {  
    @BeanVehicle engine()  
    {  
    return new Vehicle();  
    }  
    }  

**@ComponentScan:** It is used when we want to scan a package for beans. It is used with the annotation @Configuration. We can also specify the base packages to scan for Spring Components.

**Example**

    @ComponentScan(basePackages = "com.javatpoint")  
    @Configuration  
    public class ScanComponent  
    {  
    // ...  
    }  

**@Bean:** It is a method-level annotation. It is an alternative of XML <bean> tag. It tells the method to produce a bean to be managed by Spring Container.

**Example**

    @Bean  
    public BeanExample beanExample()   
    {  
    return new BeanExample ();  
    } 


## Spring Framework Stereotype Annotations

**@Component:** It is a class-level annotation. It is used to mark a Java class as a bean. A Java class annotated with **@Component** is found during the classpath. The Spring Framework pick it up and configure it in the application context as a **Spring Bean**.

**Example**


    @Component  
    public class Student  
    {  
    .......  
    } 

**@Controller:** The @Controller is a class-level annotation. It is a specialization of **@Component**. It marks a class as a web request handler. It is often used to serve web pages. By default, it returns a string that indicates which route to redirect. It is mostly used with **@RequestMapping** annotation.

**Example**

    @Controller  
    @RequestMapping("books")  
    public class BooksController   
    {  
    @RequestMapping(value = "/{name}", method = RequestMethod.GET)  
    public Employee getBooksByName()   
    {  
    return booksTemplate;  
    }  
    }  

**@Service:** It is also used at class level. It tells the Spring that class contains the **business logic**.
**Example**


    
    @Service  
    public class TestService  
    {  
    public void service1()  
    {  
    //business code  
    }  
    }  

**@Repository:** It is a class-level annotation. The repository is a **DAOs** (Data Access Object) that access the database directly. The repository does all the operations related to the database.


    @Repository   
    public class TestRepository  
    {  
    public void delete()  
    {     
    //persistence code  
    }  
    }



## Spring Boot Annotations
- **@EnableAutoConfiguration:** It auto-configures the bean that is present in the classpath and configures it to run the methods. The use of this annotation is reduced in Spring Boot 1.2.0 release because developers provided an alternative of the annotation, i.e. **@SpringBootApplication**.
- **@SpringBootApplication:** It is a combination of three annotations **@EnableAutoConfiguration, @ComponentScan,** and **@Configuration**.

**Spring MVC and REST Annotations**

- **@RequestMapping:** It is used to map the **web requests**. It has many optional elements like **consumes, header, method, name, params, path, produces**, and **value**. We use it with the class as well as the method.

**Example**

    @Controller  
    public class BooksController   
    {  
    @RequestMapping("/computer-science/books")  
    public String getAllBooks(Model model)  
    {  
    //application code  
    return "bookList";  
    }  


- **@GetMapping**

It maps the **HTTP GET** requests on the specific handler method. It is used to create a web service endpoint that **fetches** It is used instead of using: **@RequestMapping(method = RequestMethod.GET)**


- **@PostMapping**

It maps the **HTTP POST** requests on the specific handler method. It is used to create a web service endpoint that **creates** It is used instead of using: **@RequestMapping(method = RequestMethod.POST)**


- **@PutMapping**

It maps the **HTTP PUT** requests on the specific handler method. It is used to create a web service endpoint that **creates** or **updates** It is used instead of using: **@RequestMapping(method = RequestMethod.PUT)**


- **@DeleteMapping**

It maps the **HTTP DELETE** requests on the specific handler method. It is used to create a web service endpoint that **deletes** a resource. It is used instead of using: **@RequestMapping(method = RequestMethod.DELETE)**


- **@PatchMapping**

It maps the **HTTP PATCH** requests on the specific handler method. It is used instead of using: **@RequestMapping(method = RequestMethod.PATCH)**


- **@RequestBody**

It is used to **bind** HTTP request with an object in a method parameter. Internally it uses **HTTP MessageConverters** to convert the body of the request. When we annotate a method parameter with **@RequestBody,** the Spring framework binds the incoming HTTP request body to that parameter.


- **@ResponseBody**

It binds the method return value to the response body. It tells the Spring Boot Framework to serialize a return an object into JSON and XML format.


- **@PathVariable**

It is used to extract the values from the URI. It is most suitable for the RESTful web service, where the URL contains a path variable. We can define multiple @PathVariable in a method.


- **@RequestParam**

It is used to extract the query parameters form the URL. It is also known as a **query parameter**. It is most suitable for web applications. It can specify default values if the query parameter is not present in the URL.


- **@RequestHeader**

It is used to get the details about the HTTP request headers. We use this annotation as a **method parameter**. The optional elements of the annotation are **name, required, value, defaultValue.** For each detail in the header, we should specify separate annotations. We can use it multiple time in a method


- **@RestController:**

It can be considered as a combination of **@Controller** and **@ResponseBody** annotations**.** The @RestController annotation is itself annotated with the @ResponseBody annotation. It eliminates the need for annotating each method with @ResponseBody.


- **@RequestAttribute**

It binds a method parameter to request attribute. It provides convenient access to the request attributes from a controller method. With the help of @RequestAttribute annotation, we can access objects that are populated on the server-side.



مرجع :
https://www.javatpoint.com/spring-boot-tutorial

